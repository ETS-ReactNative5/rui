<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title></title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style type="text/css">
		html {
			width: 100%;
			height: 100%;
		}

		body {
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
			overflow: hidden;
			/* background: -webkit-radial-gradient(#1a5970 0%, #000000 100%);
      background: radial-gradient(#1a5970 0%, #000000 100%); */
		}

		.clearfix {
			*zoom: 1;
		}

		.clearfix:after {
			content: ".";
			display: block;
			height: 0px;
			font-size: 0px;
			clear: both;
			visibility: hidden;
		}
	</style>
</head>

<body>
	<script type="text/javascript">
		// 582. 杀死进程
		// 给 n 个进程，每个进程都有一个独一无二的 PID （进程编号）和它的 PPID （父进程编号）。

		// 每一个进程只有一个父进程，但是每个进程可能会有一个或者多个孩子进程。它们形成的关系就像一个树状结构。只有一个进程的 PPID 是 0 ，意味着这个进程没有父进程。所有的 PID 都会是唯一的正整数。

		// 我们用两个序列来表示这些进程，第一个序列包含所有进程的 PID ，第二个序列包含所有进程对应的 PPID。

		// 现在给定这两个序列和一个 PID 表示你要杀死的进程，函数返回一个 PID 序列，表示因为杀这个进程而导致的所有被杀掉的进程的编号。

		// 当一个进程被杀掉的时候，它所有的孩子进程和后代进程都要被杀掉。

		// 你可以以任意顺序排列返回的 PID 序列。

		// 示例 1:

		// 输入: 
		// pid =  [1, 3, 10, 5]
		// ppid = [3, 0, 5, 3]
		// kill = 5
		// 输出: [5,10]
		// 解释: 
		// 		  3
		// 		/   \
		// 	   1     5
		// 			/
		// 		   10
		// 杀掉进程 5 ，同时它的后代进程 10 也被杀掉。
		

		// 注意:

		// 被杀掉的进程编号一定在 PID 序列中。
		// n >= 1.

		var killProcess = function(pid, ppid, kill) {
			var map = {}, rs = [];
			ppid.forEach((item, index) => {
				if(!map[item]) {
					map[item] = [];
				}
				if(!map[pid[index]]) {
					map[pid[index]] = [];
				}
				if(pid[index] !== undefined) {
					map[item].push(pid[index]);
				}
			});
			let get = function(value, rs) {
				rs.push(value);
				if(map[value]) {
					map[value].forEach(item => {
						if(map[item]) {
							get(item, rs);
						} else {
							rs.push(item);
						}
					});
				}
			}
			get(kill, rs);
			return rs;
		};

		console.log(killProcess([1, 3, 10, 5], [3, 0, 5, 3], 5));
	</script>
</body>

</html>