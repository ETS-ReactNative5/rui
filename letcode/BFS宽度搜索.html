<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<title></title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<style type="text/css">
		html {
			width: 100%;
			height: 100%;
		}

		body {
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
			overflow: hidden;
			/* background: -webkit-radial-gradient(#1a5970 0%, #000000 100%);
      background: radial-gradient(#1a5970 0%, #000000 100%); */
		}

		.clearfix {
			*zoom: 1;
		}

		.clearfix:after {
			content: ".";
			display: block;
			height: 0px;
			font-size: 0px;
			clear: both;
			visibility: hidden;
		}
	</style>
</head>

<body>
	<script type="text/javascript">

		var computeSimilarities = function (docs) {
			//初始化队列状态
			head = 1, tail = 1;
			while (head <= tail) {
				for (ket i = 1; i <= 方案数; i++) {
					if (可行) {
						tail++;
						//记录新节点信息
						if (找到目标) {
							return;
						}
					}
				}
				head++; //进入下一节点
			}
		};
		console.log(computeSimilarities(['a', 'b', 'c']));


		const averageOfLevels = (root) => {
			if (!root) {
				return [];
			}
			const rs = [];
			const cur = [root];
			while (cur.length) {
				const size = cur.length;
				//let sum = 0;
				for (let i = 0; i < size; i++) {
					const cur = cur.shift();
					//sum += cur.val;
					if (cur.left) {
						cur.push(cur.left);
					}
					if (cur.right) {
						cur.push(cur.right);
					}
				}
				//rs.push(sum / size);
			}
			return rs;
		};


		const averageOfLevels = (root) => {
			// 狗不理
			if (!root) {
				return [];
			}

			// 1. 设置最终的结果为
			const result = [];

			// 2. 设置当前层
			let cur = [root];

			// 3. 广度优先搜索（BFS）
			while (cur.length) {
				// 3.1 设置下一层
				const nextRoot = [];

				// 3.2 设置当前层的总和
				let sun = 0;

				// 3.3 遍历当前层
				for (let i = 0; i < cur.length; i++) {
					// 3.3.1 统计当前层的总和
					sun += cur[i].val;

					// 3.3.2 如果存在左子树
					if (cur[i].left) {
						nextRoot.push(cur[i].left);
					}

					// 3.3.3 如果存在右子树
					if (cur[i].right) {
						nextRoot.push(cur[i].right);
					}
				}

				// 3.4 上下层交接
				result.push(sun / cur.length); // 平均值 = 总和 / 数组长度
				cur = nextRoot; // 交接
			}

			// 4. 返回结果
			return result;
		};
	</script>
</body>

</html>